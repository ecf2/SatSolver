exports.solve = function solve(fileName) {

    let formula = readFormula(fileName)
    let result = doSolve(formula.clauses, formula.variables)
    
    return result // two fields: isSat and satisfyingAssignment
  }
  
  // Receives the current assignment and produces the next one
  function nextAssignment(currentAssignment) {
      let nextAssignment = currentAssignment;
      let position = currentAssignment.length - 1; //counter starts at the last element of the assignment

      //Looks for a false in the array from the end and saves that position
      while((position>=0) && (currentAssignment[position] == true)) {
          position = position - 1;
      }   

      //From the position saved, all the elements become its opposite
      for (let i = position; i < nextAssignment.length; i++) {
          nextAssignment[i] = !currentAssignment[i];
      }
      return nextAssignment;
  }
      
   
  
  // Checks if the clauses are satisfables 
  function doSolve(clauses, assignment) {
    let isSat = false;
    let initialCondition = false;
    
    //Checks if the formula is satisfiable and if it hasn't tried all the values for the variables and then solves 
    while (!isSat && !initialCondition) {
      initialCondition = true;
      isSat = true;
      for (let i= 0; i<clauses.length & isSat==true; i++){
          let clausesvalue = false;
          for (let j=0; j<clauses[i].length & clausesvalue==false; j++){
              if (clauses[i][j]<0){
                  clausesvalue = clausesvalue || !(assignment[Math.abs(clauses[i][j])-1]); //variables
              }else{
                   clausesvalue = clausesvalue || assignment[clauses[i][j]-1]; //variables
              }
              
          }
          
          isSat = isSat && clausesvalue; //clauses
      }
  
      // If isSat is not true, gets the next assignment and try again. 
      if (isSat==false){
          assignment = nextAssignment(assignment);
      }
  
      // Checks if it has tried all the possible values for the variables
      for (let i = 0; i<assignment.length; i++){
          if (assignment[i] == true){
              initialCondition = false;
          } 
      }
     
    }
  
    // Creates the object that it will be returned
    let result = {'isSat': isSat, satisfyingAssignment: null};
  
    // If the problem is satisfiable, one of the atributes of the object receives the array which satisfies the problem
    if (isSat) {
      result.satisfyingAssignment = assignment;
    }
    return result;
  }
   
  //Reads the file
  function readFormula(fileName) {
    let fs = require('fs');
    let text = fs.readFileSync(fileName, 'utf8');
    text = text.split('\n'); // Splits text into an array containing the lines of text extracted from the file. 
    let clauses = readClauses(text);
    let variables = readVariables(clauses);
    
    // In the following line, text is passed as an argument so that the function
    // is able to extract the problem specification.
    let specOk = checkProblemSpecification(text, clauses, variables);
  
    let result = { 'clauses': [], 'variables': [] }
    if (specOk) {
      result.clauses = clauses;
      result.variables = variables;
    }
    return result;
  };
    
  function readClauses (text){
      let clauses = []; // array of clauses
      let noSpace = [];
      for (let i = 0; i < text.length; i++){
         
          if (!(text[i].startsWith("c") || text[i].startsWith('p')) && text[i].length>0) {  
          let aux = text[i]; // var aux gets the lines that contains the clauses 
          aux = aux.split(' '); // var aux becomes an array without the spaces
  
          //removes any extra spaces
              for (let j = 0; j < aux.length; j++) {
                  if (aux[j] != '') {
                      noSpace[noSpace.length] = aux[j];
                  }
              }
              if (noSpace[noSpace.length - 1] == 0){
                  noSpace.pop(); // removes the last element of the array
                  clauses[clauses.length] = noSpace;
                  noSpace = [];
              }
          }
      }

      if (clauses[clauses.length-1].length==0){
          clauses.pop();
      }  
      return clauses;
  }
  
  function readVariables (clauses){
      let variable = [];
      // Fills the array of variables with zeros
      for (let i = 0; i<clauses.length;i++){
          for (let j=0; j<clauses[i].length; j++){
              clauses[i][j] = clauses[i][j] - '0';
              variable[Math.abs(clauses[i][j])-1] = false;
          }
      }
      return variable;
  }
  
    function checkProblemSpecification (text, clauses, variables){  
      var theresP = false;
      //Checks if there is a p line
      for (let i = 0; i<text.length;i++){
          if (text[i].startsWith('p')){
              theresP = true;
          }
      }
      //If there is a p line, checks if the number of variables and clauses are correct
      if (theresP==true){
          for (let i = 0; i<text.length; i++){
              if (text[i].startsWith('p')){
                  if (text[i].includes(variables.length + " " + clauses.length)){
                      return true;
                  } else {
                  return false;
                  }
              }
           }
      // If there is not, returns true so the program runs anyway
      } else{
          return true;
      }
   }
  
   